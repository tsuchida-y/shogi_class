# 将棋AIシステム 説明資料（3分版）

## 1. システム全体の流れ

```
初期盤面作成 → ゲームループ → 詰み判定で終了
               ↓
       [先手(人間)のターン]
         - 入力受付（move/drop）
         - 合法手チェック
         - 盤面更新
               ↓
       [後手(AI)のターン]
         - ミニマックス探索（3手先読み）
         - 最善手を選択
         - 盤面更新
```

**ポイント**: `play_game()`関数内のwhileループで交互にターンを進める

## 2. データ構造の工夫

### 盤面表現
```python
board = {(段, 筋): '駒'}  # 例: {(7,7): 'p', (1,5): 'K'}
```
- **辞書を採用した理由**: 空きマスをNoneで管理する必要がなく、メモリ効率が良い
- **座標検索がO(1)**: 高速な駒の参照が可能

### イミュータブル設計
```python
def make_move(board, frm, to, hands, turn):
    b = board.copy()  # 元の盤面を変更しない
    h = {'sente': hands['sente'][:], 'gote': hands['gote'][:]}
    # ... 処理 ...
    return b, h  # 新しい盤面を返す
```
- **なぜ必要か**: ミニマックス探索で元の盤面を保持するため
- **効果**: 何手も先読みしながら、現在の盤面に戻れる

## 3. AI実装の核心部分

### ミニマックス法 + αβ枝刈り
```python
def minimax(board, hands, depth, alpha, beta, maxi, turn):
    if depth == 0:
        return evaluate_board(board, turn), None
    
    for move in get_all_legal_moves(board, hands, turn):
        # 仮想的に手を指す
        val, _ = minimax(新盤面, depth-1, alpha, beta, not maxi, 相手)
        
        # αβ枝刈り: 探索を打ち切る判定
        if beta <= alpha:
            break  # この分岐は探索不要
```

**効果**: 深さ3の探索を現実的な時間で実行可能（約√b倍の効率化）

### 評価関数の構成（3層構造）
1. **基本評価（E1-E5）**: 駒の価値合計（飛1000点、角800点...）
2. **玉の安全度（E6）**: 周囲8マスの攻撃判定 → ±10点/マス
3. **駒の働き（E7）**: 敵陣接近度+2点/段、中央配置+5点

## 4. 特殊ルール実装の工夫

### 打ち歩詰め判定
```python
def is_uchifuzume(board, hands, pos, turn):
    # 1. 仮想的に歩を打つ
    test_board, _ = drop_piece(board, hands, 'P', pos, turn)
    
    # 2. 相手が王手状態か？
    if not is_check(test_board, 相手):
        return False
    
    # 3. 相手に逃げ道があるか？
    if len(get_all_legal_moves(test_board, hands, 相手)) > 0:
        return False
    
    # 王手 + 逃げ道なし = 打ち歩詰め（禁止）
    return True
```

**実装のポイント**: 「もし指したら」をシミュレートして判定

### 合法手生成のフィルタリング
```python
get_all_legal_moves():
    moves = []
    # 1. 盤上の駒を動かす手
    # 2. 持ち駒を打つ手
    # ↓ フィルタリング
    # - 自殺手（王手に飛び込む）→ is_safe()
    # - 二歩 → has_pawn_on_file()
    # - 打ち歩詰め → is_uchifuzume()
    # - 行き所のない駒 → is_dead_drop()
```

## 5. 実装の工夫点まとめ

| 要素 | 工夫点 | 効果 |
|------|--------|------|
| **データ構造** | 辞書+イミュータブル | 探索効率↑、バグ↓ |
| **AI探索** | αβ枝刈り実装 | 探索速度が約√b倍 |
| **評価関数** | 3層構造（基本+安全+働き） | 玉の守りと攻撃バランスを評価 |
| **特殊ルール** | シミュレーション判定 | 複雑なルールを正確に実装 |
| **自動成り** | 敵陣出入りで自動判定 | ユーザー操作を簡略化 |

## 6. テスト完了状況

- ✅ 全11テストケース合格
- ✅ 二歩禁止、打ち歩詰め、自殺手、王手判定、詰み判定
- ✅ DOCUMENT.md の全要件（P1-P5, E1-E7, A1-A3, T1-T4）実装完了

## 7. デモ時の説明順序（推奨）

1. **盤面表示を見せる**（30秒）
   - 「9×9盤面で先手が下、持ち駒も表示されます」
   
2. **データ構造の説明**（30秒）
   - 「辞書による盤面表現とイミュータブル設計で探索が効率的」
   
3. **AI動作のデモ**（60秒）
   - 「ミニマックス+αβ枝刈りで3手先まで読みます」
   - 実際に1手指してAIの応手を見せる
   
4. **特殊ルールの説明**（30秒）
   - 「打ち歩詰めなど複雑なルールも実装しています」
   
5. **評価関数の工夫**（30秒）
   - 「駒の価値だけでなく、玉の安全度と駒の働きも評価」

---

**合計**: 約3分（180秒）
